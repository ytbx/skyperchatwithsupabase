import{spawn as e}from"node:child_process";import{arch as t,platform as n}from"node:os";import r from"node:path";(n()!==`win32`||t()!==`x64`)&&console.warn(`This package is currently only available for Windows 10 x64 and later`);let i=r.resolve(__dirname,`../`,`bin`);function a(e){i=e}function o(){return r.resolve(i,`${n()}-${t()}`,`ApplicationLoopback.exe`)}function s(){return r.resolve(i,`${n()}-${t()}`,`ProcessList.exe`)}async function c(){let t=e(s(),{detached:!0,stdio:`pipe`});return t.stdout.setEncoding(`utf8`),new Promise(e=>{let n=[],r=``;t.stdout.on(`data`,e=>{r+=e}),t.stdout.on(`close`,()=>{let t=r.split(/\r?\n/);for(let e of t){let t=e.split(`;`);if(t.length>=3){let e=t[0].trim(),r=t[1].trim(),i=t[2].trim();e&&r&&n.push({processId:e,hwnd:r,title:i})}}e(n)}),t.on(`error`,t=>{console.error(`[native-audio-loopback] ProcessList spawn error:`,t),e([])})})}const l=new Map;function u(t,n){if(l.has(t))throw Error(`An audio capture with process id of ${t} is already started`);let i=[t,n.mode||`include`],a=e(`${r.resolve(__dirname,o())}`,i,{detached:!0,stdio:`pipe`});return l.set(t,a),a.stdout.on(`data`,e=>{n.onData?.(e)}),t}function d(e){let t=l.get(e);return t?(t.kill(),l.delete(e),!0):!1}function f(e,t){return u(e,{onData:t.onData,mode:`exclude`})}async function p(e){let t=e.toString().trim(),n=await c();console.log(`[native-audio-loopback] Searching for PID for HWND: "${t}"`);let r=n.find(e=>e.hwnd===t);return r?(console.log(`[native-audio-loopback] ✓ Found PID: ${r.processId} for HWND: ${t} (${r.title})`),r.processId):(console.warn(`[native-audio-loopback] ✗ FAILED to find PID for HWND: "${t}"`),null)}export{f as captureSystemAudioExcluding,c as getActiveWindowProcessIds,o as getLoopbackBinaryPath,s as getProcessListBinaryPath,p as getWindowPid,a as setExecutablesRoot,u as startAudioCapture,d as stopAudioCapture};